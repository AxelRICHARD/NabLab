module Glace2d;

with Math.*;

connectivities {
	nodes: (∅) → {node};
	cells: (∅) → {cell};
	nodesOfCell: (cell) → {node};
}

functions {
	tensProduct: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct: (ℝ²ˣ², ℝ²) → ℝ²;
	matrixDeterminant: (ℝ²ˣ²) → ℝ;
	inverseMatrix: (ℝ²ˣ², ℝ) → ℝ²ˣ²;
}


// ****************************************************************************
// * Options du schéma Glace Euler/Sans reconstruction
// ****************************************************************************

// Options obligatoires pour générer
const ℝ LENGTH = 1.125;
const ℕ X_EDGE_ELEMS = 4;
const ℕ Y_EDGE_ELEMS = 4;
const ℝ option_stoptime = 0.1;
const ℕ option_max_iterations = 32768;

// Mesh options
ℝ option_δt_min = 1.0e-12;
ℝ option_δt_max = 0.01;
ℝ option_δt_control = 0.1;            // Contrôle du pas de temps hydrodynamique
ℝ option_δt_min_variation = 0.99;     // Décroissance maximale tolérée du pas de temps
ℝ option_δt_max_variation = 0.10;     // Amplitude maximale de croissance du pas de temps
ℾ option_δt_last_exact = true;


// ****************************************************************************
// * Déclaration des variables aux noeuds
// ****************************************************************************
ℝ² coord[nodes];
ℝ² node_u[nodes];						// Vitesse nodale du maillage
ℝ² node_u_second_member[nodes];			// Matrice aux sommets pour le calcul de la vitesse
ℝ²ˣ² node_u_matrix[nodes];				// Second membre aux sommets pour le calcul de la vitesse



// ****************************************************************************
// * Déclaration des variables aux mailles
// ****************************************************************************
ℝ m[cells];								// Masse
ℝ ρ[cells];								// Densités
ℝ p[cells];								// Pression
ℝ² u[cells]; 							// Vitesse moyenne
ℝ css[cells];
ℝ glace_δt[cells];
ℝ absCQs[cells, nodesOfCell];
ℝ² CQs[cells, nodesOfCell];				// Résultantes aux sommets
ℝ²ˣ² AQs[cells, nodesOfCell];			// Matrices de contributions aux sommets
ℝ ρE[cells];							// Énergie massique
ℝ² reconstructed_u[cells, nodesOfCell];	// Tableau des vitesses reconstruites
ℝ reconstructed_p[cells, nodesOfCell];	// Tableau des pressions reconstruites
ℝ² momentum_fluxes_∑[cells];
ℝ total_energy_fluxes_∑[cells];




// ****************************************************************************
// * Globals
// ****************************************************************************
ℝ δt, global_δt, t;



// ****************************************************************************
// * Partie boucle de calcul ]+0.0,+∞[ 
// ****************************************************************************

// ****************************************************************************
// * computeAQsMatrices
// ****************************************************************************

ComputeAQsMatrices: ∀j∈cells(), {
	ℝ ρc = ρ{j}*css{j};
	∀r∈nodesOfCell(j), {
		AQs{j,r} = tensProduct(CQs{j,r}, CQs{j,r}); // vérifier l'operateur
		AQs{j,r} = AQs{j,r} * (ρc / absCQs{j,r});	
	}
}

TemporalSchemeReconstructPressure: ∀j∈cells(), ∀r∈nodesOfCell(j), reconstructed_p{j,r} = p{j};
TemporalSchemeReconstructVelocity: ∀j∈cells(), ∀r∈nodesOfCell(j), reconstructed_u{j,r} = u{j};
TemporalSchemeIniMatricesAndSecondMember: ∀r∈nodes(), {
	node_u_matrix{r} = {{0.0,0.0}, {0.0,0.0}};
	node_u_second_member{r} = {0.0,0.0};	
}

TemporalSchemeAssembleMatricesAndSecondMember: ∀j∈cells(), ∀r∈nodesOfCell(j), {
	ℝ²ˣ² local_matrix = AQs{j,r};
    node_u_matrix{r} = node_u_matrix{r} + local_matrix;
	node_u_second_member{r} = node_u_second_member{r} + matVectProduct(local_matrix, reconstructed_u{j,r}); // vérifier l'operateur
    node_u_second_member{r} = node_u_second_member{r} + CQs{j,r} * reconstructed_p{j,r};
}


// ****************************************************************************
// * Le calcul aux boundaries se fait ici @ 13.1,13.2
// ****************************************************************************

TemporalSchemeComputeNodesVelocity: ∀r∈nodes(), {
	ℝ determinent = matrixDeterminant(node_u_matrix{r});
	node_u_matrix{r} = inverseMatrix(node_u_matrix{r}, determinent);
	node_u{r} = matVectProduct(node_u_matrix{r}, node_u_second_member{r});
}
  
TemporalSchemeIniFluxesSum: ∀j∈cells(), {
	momentum_fluxes_∑{j} = {0.0, 0.0};
	total_energy_fluxes_∑{j} = 0.0;
}

// ****************************************************************************
// * temporalSchemeComputeStandardFluxesSum
// ****************************************************************************
TemporalSchemeComputeStandardFluxesSum: ∀j∈cells(), ∀r∈nodesOfCell(j), {
	ℝ² δu = reconstructed_u{j,r} - node_u{r};
	ℝ² FQs = matVectProduct(AQs{j,r}, δu); // verifier l'operateur
    FQs = FQs + reconstructed_p{j,r} * CQs{j,r};
    momentum_fluxes_∑{j} = momentum_fluxes_∑{j} - FQs;
    total_energy_fluxes_∑{j} = total_energy_fluxes_∑{j} - dot(FQs, node_u{r}); // verifier l'operateur
}

TemporalSchemeApplyFluxesStandard: ∀j∈cells(), {
	u{j} = u{j} + δt * momentum_fluxes_∑{j} / m{j};
	ρE{j} = ρE{j} + δt * total_energy_fluxes_∑{j} / m{j};
}

TemporalSchemeMoveNodes: ∀r∈nodes(), coord{r} = coord{r} + δt * node_u{r};

GlobalDeltaTReduction: global_δt = reduceMin{j∈cells()}(glace_δt{j});

GlaceTimeStepCtrl: {
	ℝ new_δt = option_δt_control * global_δt;
	// on calcule les variations min et max autorisées
	ℝ max_time_step = (1.0 + option_δt_max_variation) * δt;
	ℝ min_time_step = (1.0 - option_δt_min_variation) * δt;
	if (new_δt > max_time_step) new_δt = max_time_step;
	if (new_δt < min_time_step) new_δt = min_time_step;
	new_δt = min(new_δt, option_δt_max);
	new_δt = max(new_δt, option_δt_min);
	
	// le dernier calcul se fait exactement au temps final
	if (option_δt_last_exact && ((t + new_δt) > option_stoptime)) new_δt = option_stoptime - t;
	//if ((time>=option_stoptime) || (new_δt==0.0)) exit;
  	δt = new_δt;
  	//if (option_max_iterations!=0 && iteration >= option_max_iterations) exit;
}
