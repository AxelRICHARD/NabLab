/*******************************************************************************
 * Copyright (c) 2018 CEA
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 * 	Benoit Lelandais - initial implementation
 * 	Marie-Pierre Oudot - initial implementation
 * 	Jean-Sylvain Camier - Nabla generation support
 *******************************************************************************/
module ExplicitHeatEquation;

with Math.*;
with LinearAlgebra.*;

items { node, cell, face }

connectivities {
	nodes: → {node};
	cells: → {cell};
	faces: → {face};
	neighbourCells: cell → {cell};
	nodesOfFace: face → {node};
	cellsOfFace: face → {cell};
	nodesOfCell: cell → {node};
	commonFace: cell × cell → face;
}

const ℝ X_LENGTH = 2.0;
const ℝ Y_LENGTH = 2.0;
const ℝ u0 = 1.0;
const ℝ[2] vectOne = ℝ[2](1.0);

// NabLab Mandatory Options
const ℕ X_EDGE_ELEMS = 40;
const ℕ Y_EDGE_ELEMS = 40;
const ℕ Z_EDGE_ELEMS = 1;
const ℝ X_EDGE_LENGTH = X_LENGTH / X_EDGE_ELEMS;
const ℝ Y_EDGE_LENGTH = Y_LENGTH / Y_EDGE_ELEMS;
const ℝ option_stoptime = 1.0;
const ℕ option_max_iterations = 500000000;

ℝ t=0.0; 
ℝ δt=0.001;
ℝ[2] X{nodes}, Xc{cells}; // Position of nodes and cells center of gravity 
ℝ xc{cells}, yc{cells}; // Abscissa and ordinate of cells center of gravity so they can be plotted in vtk file
ℝ u{cells}; // Temperature
ℝ V{cells}; // Volume of cells
ℝ D{cells}; // Cell centered conductivity
ℝ faceLength{faces}, faceConductivity{faces};
//ℝ α{cells, neighbourCells}; 
//ℝ α_self{cells};
ℝ α{cells, cells}; 
InitXc: ∀c∈cells(), Xc{c} = 0.25 * ∑{p∈nodesOfCell(c)}(X{p});  // ne fonctionne que sur des parallélogrammes

InitXcAndYc: ∀c∈cells(), {
	xc{c} = Xc{c}[0]; 
	yc{c} = Xc{c}[1];
}

InitU: ∀c∈cells(),
	if (norm(Xc{c} - vectOne) < 0.5)
		u{c} = u0;
	else 
		u{c} = 0.0; // Initial circle in the center with value u0

InitD: ∀c∈cells(), D{c} = 1.0; // 

// Computing time step with cfl = 0.96
computeDeltaTn: δt = reduceMin{c∈cells()}(X_EDGE_LENGTH*Y_EDGE_LENGTH/D{c}) * 0.24;

ComputeV: ∀j∈cells(), V{j} = 0.5 * ∑{p∈nodesOfCell(j)}(det(X{p}, X{p+1}));
ComputeFaceLength: ∀f∈faces(), faceLength{f} = 0.5 * ∑{p∈nodesOfFace(f)}(norm(X{p}-X{p+1}));
ComputeFaceConductivity: ∀f∈faces(), faceConductivity{f} = 2.0 * ∏{c1∈cellsOfFace(f)}(D{c1}) / ∑{c2∈cellsOfFace(f)}(D{c2});

///* Assembling of the diffusion matrix */
//// Extra diagonal terms 
//computeAlphaCoeff: ∀c∈cells(), ∀d∈neighbourCells(c), f=commonFace(c,d),
//	α{c, d} = δt / V{c} * (faceLength{f} *  faceConductivity{f}) / norm(Xc{c}-Xc{d});
//// Diagonal terms		
//computeOwnAlphaCoeff:  ∀c∈cells(), α_self{c} = 1 - ∑{d∈neighbourCells(c)}(α{c, d});
//UpdateU: ∀c∈cells(), u^{n+1}{c} = α_self{c} * u{c} + ∑{d∈neighbourCells(c)} (α{c, d} * u{d});


/* Assembling of the diffusion matrix */
computeAlphaCoeff: ∀c∈cells(), {
	ℝ αDiag = 0.0;
	∀d∈neighbourCells(c), f=commonFace(c,d), {
		ℝ αExtraDiag = δt / V{c} * (faceLength{f} *  faceConductivity{f}) / norm(Xc{c}-Xc{d});
		α{c, d} = αExtraDiag;
		αDiag = αDiag + αExtraDiag;
	}
	α{c, c} = 1 - αDiag;
}
	
//UpdateU: ∀c∈cells(), u^{n+1}{c} = α{c, c} * u{c} + ∑{d∈neighbourCells(c)} (α{c, d} * u{d});
UpdateU: u^{n+1} = solveLinearSystem(α, u);

ComputeTn: t^{n+1}=t+δt;
