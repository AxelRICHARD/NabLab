module Test;

with Math.*;

items { node }
set	nodes: → {node};

//def f: ℝ → ℝ;
//def f: ℝ[2] → ℝ;
//def g: x | ℝ[x] → ℝ[x];

def h: ℝ[2] → ℝ[2], (a) → {
	return 2 * a;
}

def i: a | ℝ[a] → ℝ[a], (x) → {
	return 2 * x;
}

def	j: a | ℝ[a] → ℝ[a], (x) → {
	ℝ[a] y;
	∀i∈[0;a[, y[i] = 2 * x[i];
	return y;
}

def k: b | ℝ[b] → ℝ[b], (x) → return j(x);

const ℝ X_EDGE_LENGTH = 0.01;
const ℝ Y_EDGE_LENGTH = X_EDGE_LENGTH;
const ℕ X_EDGE_ELEMS = 100;
const ℕ Y_EDGE_ELEMS = 10;
const ℕ Z_EDGE_ELEMS = 1;

const ℝ option_stoptime = 0.2;
const ℕ option_max_iterations = 20000;

ℝ t;
ℝ[2] X{nodes};

ℝ[2] u = [0.0, 0.1];
ℝ[3] v = [0.0, 0.1, 0.2];
ℝ[2] w1;
ℝ[2] w2;
ℝ[3] w3;
ℝ[2] w4;
ℝ[3] w5;
ℝ[2] w6;

j1: w1 = h(u);
j2: w2 = i(u);
j3: w3 = i(v);
j4: w4 = j(u);
j5: w5 = j(v);
j6: w6 = k(u);

//j1: ∀r∈nodes(), ℝ[2] ddd = g(X{r});