/*******************************************************************************
 * Copyright (c) 2018 CEA
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 * 	Benoit Lelandais - initial implementation
 * 	Marie-Pierre Oudot - initial implementation
 * 	Jean-Sylvain Camier - Nabla generation support
 *******************************************************************************/
module Whiteheat;

with Math.*;

items { node, cell, face }

connectivities {
	nodes: (∅) → {node};
	cells: (∅) → {cell};
	faces: (∅) → {face};
	neighbourCells: (cell) → {cell};
	nodesOfFace: (face) → {node};
	nodesOfCell: (cell) → {node};
	commonFace: (cell, cell) → face;
}

// Options obligatoires pour compiler
const ℝ LENGTH = 1.0;
const ℕ X_EDGE_ELEMS = 8;
const ℕ Y_EDGE_ELEMS = 8;
const ℕ Z_EDGE_ELEMS = 1;
const ℝ option_stoptime = 0.1;
const ℕ option_max_iterations = 48;

ℝ t=0.0; 
ℝ δt=0.001;
ℝ² X[nodes], center[cells];
ℝ u[cells], V[cells], f[cells], tmp[cells], surface[faces];

IniF: ∀j∈cells(), f{j} = 0.0;
IniCenter: ∀j∈cells(), center{j} = 0.25 * ∑{r∈nodesOfCell(j)}(X{r});  // ne fonctionne que sur des parallélogrammes
IniUn: ∀j∈cells(), u{j}=0.0;
ComputeV: ∀j∈cells(), V{j} = 0.5 * ∑{r∈nodesOfCell(j)}(det(X{r}, X{►(r)}));
ComputeSurface: ∀f∈faces(), surface{f} = 0.5 * ∑{r∈nodesOfFace(f)}(norm(X{r}-X{►(r)}));
ComputeTmp: ∀j1∈cells(), tmp{j1} = δt/V{j1} * ∑{j2∈neighbourCells(j1), cf=commonFace(j1,j2)}( (u{j2}-u{j1}) / (norm(center{j2}-center{j1}) * surface{cf}));
ComputeUn: ∀j∈cells(), u{j}^{n+1}=f{j}*δt + u{j} + tmp{j};
ComputeTn: t^{n+1}=t+δt;

