/*******************************************************************************
 * Copyright (c) 2018 CEA
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 * Contributors: see AUTHORS file
 *******************************************************************************/
 
 
 
// TODO change IntVectorConstant, RealVector to allow expressions => validator for the type (idem for matrices)
// TODO Suppress StrictInitializationExpression
// TODO Change names Var->Symbol, DeclaredVar->Var, Affectation.expr->Affectation.right (idem for left)
// TODO Add missing tests of validators
// TODO Operator definition and overload



grammar fr.cea.nabla.Nabla with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate nabla "http://www.cea.fr/nabla/Nabla"

NablaModule:
	'module' name=QualifiedName ';'
	imports+=Import*
	('items' '{' items+=ItemType (',' items+=ItemType)* '}'
	connectivities+=Connectivity*)?
	functions+=(Function | Reduction)*
	instructions+=(SimpleVarDefinition | VarGroupDeclaration)*
	jobs+=Job*;

Import: 'with' importedNamespace=QualifiedNameWithWildcard ';';

/* ITEMS *************************************************/
ItemType:
	name=ID;

/* JOBS **************************************************/
Job: name=ID ':' instruction=Instruction;

/* INSTRUCTIONS ******************************************/
Iterable: Loop | ReductionCall;
Instruction: 
	SimpleVarDefinition | VarGroupDeclaration | InstructionBlock |
	Loop | Affectation | If | Return;

SimpleVarDefinition: (const?='const')? type=BaseType variable=SimpleVar '=' defaultValue=InitializationExpression ';';
VarGroupDeclaration: type=BaseType variables+=DeclaredVar (',' variables+=DeclaredVar)* ';';
InstructionBlock: '{' instructions+=Instruction+ '}';
Loop: '\u2200' iterationBlock=IterationBlock ',' body=Instruction;
Affectation: varRef=VarRef '=' expression=Expression ';';
If: 'if' '(' condition=Expression ')' then=Instruction (=>'else' else=Instruction)?;
Return: 'return' expression=Expression ';';

/* ITERATEURS ********************************************/
IterationBlock: SpaceIterationBlock | DimensionIterationBlock;
SpaceIterationBlock: range=RangeSpaceIterator (',' singletons+=SingletonSpaceIterator)*;
DimensionIterationBlock: index=DimensionIndex;

SpaceIterator: RangeSpaceIterator | SingletonSpaceIterator;
RangeSpaceIterator: name=ID '\u2208' container=ConnectivityCall; // must return a collection
SingletonSpaceIterator: name=ID '=' container=ConnectivityCall; // must return a singleton
ConnectivityCall: connectivity=[Connectivity]  '('(args+=SpaceIteratorRef (',' args+=SpaceIteratorRef)*)?')';
SpaceIteratorRef: target=[SpaceIterator] (('+' inc=INT) | ('-' dec=INT))?; // inc/dec only valid on a range

TimeIterator: 
	{InitTimeIterator} 'n=0' | 
	{NextTimeIterator} 'n+1' (hasDiv?='/' div=INT)?;


/* VARIABLES *********************************************/
Var: Arg | DeclaredVar;
DeclaredVar: SimpleVar | ConnectivityVar;
SimpleVar: name=ID;
ConnectivityVar: name=ID '{' supports+=[Connectivity] (',' supports+=[Connectivity])* '}';

/* CONNECTIVITES *****************************************/
Connectivity: 'set' name=ID ':' (inTypes+=[ItemType] ('\u00D7' inTypes+=[ItemType])*)?  '\u2192' returnType=ItemArgType ';';
ItemArgType: multiple?='{' type=[ItemType] '}' | type=[ItemType];

/* FONCTIONS / REDUCTIONS ********************************/
Function: 'def' name=ID ':' (dimVars+=DimensionVar (',' dimVars+=DimensionVar)* '|')? (inTypes+=ArgType ('\u00D7' inTypes+=ArgType)*)? '\u2192' returnType=ArgType 
	((',' '(' (inArgs+=Arg (',' inArgs+=Arg)*)? ')' '\u2192' body=Instruction) | external?=';');
Reduction: 'def' name=ID ':' (dimVars+=DimensionVar (',' dimVars+=DimensionVar)* '|')? '(' seed=Expression ',' collectionType=ArgType ')' '\u2192' returnType=ArgType ';';

Arg: name=ID;
ArgType: primitive=PrimitiveType ('[' indices+=Dimension (',' indices+=Dimension)* ']')?;
DimensionSymbol: DimensionIndex | DimensionVar;
DimensionIndex: name=ID '\u2208' '[' from=Dimension ';' to=Dimension (lte?=']'|'[');
DimensionVar: name=ID;
Dimension: DimensionOperation;
DimensionOperation returns Dimension:
	DimensionAtomic ({DimensionOperation.left=current} op=('*'|'+') right=DimensionAtomic)*;
DimensionAtomic returns Dimension: 
	{DimensionInt} value=INT |
	{DimensionSymbolReference} target=[DimensionSymbol];

/* EXPRESSIONS ******************************************/
Expression: ContractedIf;

ContractedIf returns Expression:
	Or ({ContractedIf.condition=current} '?' then=Or ':' else=Or)*;

Or returns Expression: // on garde l'attribut op pour la validation
	And ({Or.left=current} op='||' right=And)*;

And returns Expression: // on garde l'attribut op pour la validation
	Equality ({And.left=current} op='&&' right=Equality)*;

Equality returns Expression:
	Comparison ({Equality.left=current} op=('=='|'!=') right=Comparison)*;

Comparison returns Expression:
	PlusOrMinus ({Comparison.left=current} op=('>='|'<='|'>'|'<') right=PlusOrMinus)*;

PlusOrMinus returns Expression: // on garde l'attribut op pour la validation
	MulOrDiv ( ({Plus.left=current} op='+' | {Minus.left=current} op='-') right=MulOrDiv)*;

MulOrDiv returns Expression:
	Modulo ({MulOrDiv.left=current} op=('*'|'/') right=Modulo)*;

Modulo returns Expression:
	Primary ({Modulo.left=current} op=('%') right=Primary)*;

Primary returns Expression:
	{Parenthesis} '(' expression=Expression ')' | 
	{UnaryMinus} '-' expression=Primary | 
	{Not} '!' expression=Primary | 
	Atomic;

Atomic returns Expression:
	{IntConstant} value=INT |
	{RealConstant} value=REAL |
	{BoolConstant} (value?='true' | 'false') |
	{MinConstant} type=PrimitiveType '.MinValue' |
	{MaxConstant} type=PrimitiveType '.MaxValue'|
	{FunctionCall} function=[Function|QualifiedName] '(' (args+=Expression (',' args+=Expression)*)? ')' | 
	ReductionCall  | VarRef;

ReductionCall: reduction=[Reduction|QualifiedName] '{' iterationBlock=IterationBlock '}' '(' arg=Expression ')';
VarRef: variable=[Var] 
	('^{' timeIterator=TimeIterator '}')?
	('{' spaceIterators+=SpaceIteratorRef (',' spaceIterators+=SpaceIteratorRef)* '}')? 
	('[' indices+=Dimension (',' indices+=Dimension)? ']')?;

InitializationExpression: Expression | StrictInitializationExpression;

StrictInitializationExpression:	
	IntVectorConstant |
	RealVectorConstant |
	{IntMatrixConstant} '[' values+=IntVectorConstant (',' values+=IntVectorConstant)+ ']' |
	{RealMatrixConstant} '[' values+=RealVectorConstant (',' values+=RealVectorConstant)+ ']' |
	{BaseTypeConstant} type=BaseType '(' value=Expression ')'; // Expression Type is Real because there are only Real arrays for the moment but it will become expression

IntVectorConstant: '[' values+=INT (',' values+=INT)* ']';
RealVectorConstant: '[' values+=REAL (',' values+=REAL)* ']';

/* TYPES *************************************************/
BaseType: 
	{Scalar} primitive=PrimitiveType |
	{Array1D} primitive=PrimitiveType '[' size=INT ']' |
	{Array2D} primitive=PrimitiveType '[' nbRows=INT ',' nbCols=INT ']'; 

enum PrimitiveType: Int='\u2115' | Real='\u211D' | Bool='\u213E';

/* DATA TYPE *********************************************/
QualifiedName: ID ('.' ID)*;
QualifiedNameWithWildcard: QualifiedName '.*'?;

/* TERMINAUX *********************************************/
@Override 
terminal ID: '^'? ('a'..'z'|'A'..'Z'|'\u0394'..'\u03F2'|'\u220F'..'\u221A'|'_') ('a'..'z'|'A'..'Z'|'\u0394'..'\u03F2'|'0'..'9'|'\u221A'|'_')*;
//terminal REAL returns ecore::EDouble: ('0'..'9')+ '.' ('0'..'9')+ ('e'('+'|'-')('0'..'9')+)?;
terminal REAL returns ecore::EDouble: INT '.' (INT (('e'|'E')('+'|'-')INT)?)?;
//terminal DIM returns ecore::EChar: '\u00B2'..'\u00B3' | '\u2074'..'\u2079';
