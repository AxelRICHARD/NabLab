/*******************************************************************************
 * Copyright (c) 2020 CEA
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 * Contributors: see AUTHORS file
 *******************************************************************************/
package fr.cea.nabla.generator

import com.google.inject.Inject
import fr.cea.nabla.generator.ir.Nabla2Ir
import fr.cea.nabla.ir.ir.IrModule
import fr.cea.nabla.ir.transformers.CompositeTransformationStep
import fr.cea.nabla.nabla.NablaModule
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.xmi.XMLResource
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.resource.SaveOptions

import static extension fr.cea.nabla.LatexLabelServices.*
import java.util.ArrayList
import fr.cea.nabla.ir.transformers.IrTransformationStep
import fr.cea.nabla.ir.transformers.ReplaceUtf8Chars
import fr.cea.nabla.ir.transformers.OptimizeConnectivities
import fr.cea.nabla.ir.transformers.ReplaceReductions
import fr.cea.nabla.ir.transformers.FillJobHLTs

class NablaGenerator extends AbstractGenerator
{
	@Inject Nabla2Ir nabla2Ir
	@Inject NablaGeneratorMessageDispatcher dispatcher
	static val IrExtension = 'nablair'

	static def getHltIrTransformer()
	{
		val transformations = new ArrayList<IrTransformationStep>
		transformations += new ReplaceUtf8Chars
		transformations += new OptimizeConnectivities(#['cells', 'nodes', 'faces'])
		transformations += new ReplaceReductions(false)
		transformations += new FillJobHLTs
		new CompositeTransformationStep('Nabla2Hlt', transformations)
	}

	override doGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context)
	{
		try
		{
			val module = input.contents.filter(NablaModule).head
			dispatcher.post('Model size (eAllContents.size): ' + module.eAllContents.size + '\n')

			if (!module.jobs.empty)
			{
				val latexFileName = module.name.toLowerCase + '/' + module.name + '.tex'
				dispatcher.post('Generating LaTeX: ' + latexFileName + '\n')
				fsa.generateFile(latexFileName, module.latexContent)

				dispatcher.post('Nabla -> IR\n')
				val irModule = nabla2Ir.toIrModule(module)

				val t = hltIrTransformer
				t.addTraceListener([x | dispatcher.post(x)])
				val ok = t.transform(irModule)

				createAndSaveResource(fsa, irModule)
				if (!ok) throw new RuntimeException('Exception in IR transformation step: ' + t.description)
			}
		}
		catch(Exception e)
		{
			dispatcher.post('\n***' + e.class.name + ': ' + e.message + '\n')
			if (e.stackTrace !== null && !e.stackTrace.empty)
			{
				val s = e.stackTrace.head
				dispatcher.post('at ' + s.className + '.' + s.methodName + '(' + s.fileName + ':' + s.lineNumber + ')\n')
			}
			throw(e)
		}
	}

	private def getLatexContent(NablaModule m)
	'''
		\documentclass[11pt]{article}

		\use package{fontspec}
		\use package{geometry}
		\geometry{landscape}

		\title{Nabla Module «m.name»}
		\author{Generated by the NabLab environment}

		\begin{document}
		\maketitle

		«FOR j : m.jobs»
		«val latexContent = j.latex»
		«IF !latexContent.nullOrEmpty»

		\section{«j.name»}
		$«latexContent»$

		«ENDIF»
		«ENDFOR»
		\end{document}
	'''

	private def createAndSaveResource(IFileSystemAccess2 fsa, IrModule irModule)
	{
		dispatcher.post('Writing nablair file')
		val fileName = irModule.name.toLowerCase + '/' + irModule.name + '.' + IrExtension
		val uri =  fsa.getURI(fileName)
		val rSet = new ResourceSetImpl
		rSet.resourceFactoryRegistry.extensionToFactoryMap.put(IrExtension, new XMIResourceFactoryImpl)

		val resource = rSet.createResource(uri)
		resource.contents += irModule
		resource.save(xmlSaveOptions)
		dispatcher.post('... ok\n')
	}

	private def getXmlSaveOptions()
	{
		val builder = SaveOptions::newBuilder
		builder.format
		val so = builder.options.toOptionsMap
		so.put(XMLResource::OPTION_LINE_WIDTH, 160)
		return so
	}
}
