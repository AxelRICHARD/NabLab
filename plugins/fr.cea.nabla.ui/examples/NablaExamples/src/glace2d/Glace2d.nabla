/*******************************************************************************
 * Copyright (c) 2018 CEA
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 * Contributors: see AUTHORS file
 *******************************************************************************/
module Glace2d;

with Math.*;

items { node, cell, face }

set nodes: → {node};
set cells: → {cell};
set outerFaces: → {face};
set innerNodes: → {node};
set nodesOfCell: cell → {node};
set cellsOfNode: node → {cell};
set nodesOfFace: face → {node};

// only for 2D vectors
def perp: ℝ[2] → ℝ[2], (a) → return [ a[1], -a[0] ];

def trace: l | ℝ[l,l] → ℝ, (a) → {
	ℝ result = 0.0;
	∀ ia ∈ [0;l[, result = result + a[ia, ia];
	return result;
}

def tensProduct: l | ℝ[l] × ℝ[l] → ℝ[l,l], (a, b) → {
	ℝ[l,l] result;
	∀ ia ∈ [0;l[,	
		∀ ib ∈ [0;l[,
			result[ia,ib] = a[ia]*b[ib];
	return result;
}

// only for 2x2 matrices
def inverse: ℝ[2,2] → ℝ[2,2], (a) → {
	ℝ alpha = 1.0 / det(a);
	return [[ a[1,1] * alpha, -a[0,1] * alpha ],
			[-a[1,0] * alpha,  a[0,0] * alpha ]];
}

// Mesh options
const ℝ X_EDGE_LENGTH = 0.01;
const ℝ Y_EDGE_LENGTH = X_EDGE_LENGTH;
const ℕ X_EDGE_ELEMS = 100;
const ℕ Y_EDGE_ELEMS = 10;
const ℕ Z_EDGE_ELEMS = 1;

// Simulation options
const ℝ option_stoptime = 0.2;
const ℕ option_max_iterations = 20000;
  
// User options
const ℝ γ = 1.4;
const ℝ option_x_interface = 0.5;
const ℝ option_δt_ini = 1.0e-5;
const ℝ option_δt_cfl = 0.4;
const ℝ option_ρ_ini_zg = 1.0;
const ℝ option_ρ_ini_zd = 0.125;
const ℝ option_p_ini_zg = 1.0;
const ℝ option_p_ini_zd = 0.1;

ℝ t=0.0;
ℝ δt=option_δt_ini;

ℝ[2] X{nodes}, b{nodes}, bt{nodes};
ℝ[2,2] Ar{nodes}, Mt{nodes};
ℝ[2] ur{nodes};
ℝ p_ic{cells}, ρ_ic{cells}, V_ic{cells};
ℝ c{cells}, m{cells}, p{cells}, ρ{cells}, e{cells}, E{cells}, V{cells};
ℝ δtj{cells};
ℝ[2] uj{cells}, center{cells};
ℝ l{cells, nodesOfCell};
ℝ[2] C_ic{cells, nodesOfCell}, C{cells, nodesOfCell}, F{cells, nodesOfCell};
ℝ[2,2] Ajr{cells, nodesOfCell};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter: ∀j∈cells(), center{j} = 0.25 * ∑{r∈nodesOfCell(j)}(X^{n=0}{r});
IniIc: ∀j∈cells(), if (center{j}[0] < option_x_interface) {
  ρ_ic{j}=option_ρ_ini_zg;
  p_ic{j}=option_p_ini_zg;
} else {
  ρ_ic{j}=option_ρ_ini_zd;
  p_ic{j}=option_p_ini_zd;
}

ComputeCjrIc: ∀j∈cells(), ∀r∈nodesOfCell(j), 
	C_ic{j,r} = 0.5 * perp(X^{n=0}{r+1} - X^{n=0}{r-1});
IniVIc: ∀j∈cells(), V_ic{j} = 0.5 * ∑{r∈nodesOfCell(j)}(dot(C_ic{j,r}, X^{n=0}{r}));
IniM: ∀j∈cells(), m{j} = ρ_ic{j} * V_ic{j}; // m est constant

// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr: ∀j∈cells(), ∀r∈nodesOfCell(j), C{j,r} = 0.5 * perp(X{r+1} - X{r-1});
ComputeLjr: ∀j∈cells(), ∀r∈nodesOfCell(j), l{j,r} = norm(C{j,r});
Computeδtj: ∀j∈cells(), δtj{j} = 2.0 * V{j} / (c{j} * ∑{r∈nodesOfCell(j)}(l{j,r}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity: ∀j∈cells(), ρ{j} = m{j} / V{j};
ComputeEOSp: ∀j∈cells(), p{j} = (γ-1.0) * ρ{j} * e{j};
ComputeInternalEnergy: ∀j∈cells(), e{j} = E{j} - 0.5 * dot(uj{j}, uj{j});
ComputeEOSc: ∀j∈cells(), c{j} = √(γ*p{j}/ρ{j}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr: ∀j∈cells(), ∀r∈nodesOfCell(j), Ajr{j,r} = ((ρ{j}*c{j})/l{j,r}) * tensProduct(C{j,r}, C{j,r});
ComputeFjr: ∀j∈cells(), ∀r∈nodesOfCell(j), F{j,r} = p{j}*C{j,r} + matVectProduct(Ajr{j,r}, (uj{j}-ur{r}));
ComputeAr: ∀r∈nodes(), Ar{r} = ∑{j∈cellsOfNode(r)}(Ajr{j,r});
ComputeBr: ∀r∈nodes(), b{r} = ∑{j∈cellsOfNode(r)}(p{j}*C{j,r} + matVectProduct(Ajr{j,r}, uj{j}));
ComputeMt: ∀r∈innerNodes(), Mt{r} = Ar{r};
ComputeBt: ∀r∈innerNodes(), bt{r} = b{r};

OuterFacesComputations: ∀k∈outerFaces(), {
	const ℝ epsilon = 1.0e-10;
	ℝ[2,2] I = [ [1.0, 0.0], [0.0, 1.0] ];
	ℝ X_MIN = 0.0;
	ℝ X_MAX = X_EDGE_ELEMS * X_EDGE_LENGTH;
	ℝ Y_MIN = 0.0; 
	ℝ Y_MAX = Y_EDGE_ELEMS * Y_EDGE_LENGTH;
	ℝ[2] nY = [0.0, 1.0];
	
	∀r∈nodesOfFace(k), {
		// Y boundary conditions (must be done before X)
		if ((X{r}[1]-Y_MIN < epsilon) || (X{r}[1]-Y_MAX < epsilon)) {
			ℝ sign = 0.0;
			if (X{r}[1]-Y_MIN < epsilon) sign = -1.0;
			else sign = 1.0;
			ℝ[2] n = sign * nY;
      		ℝ[2,2] nxn = tensProduct(n,n);
      		ℝ[2,2] IcP = I - nxn;
			bt{r} = matVectProduct(IcP, b{r});
			Mt{r} = IcP * (Ar{r} * IcP) + nxn*trace(Ar{r});
		}

		// X boundary conditions
		if ((fabs(X{r}[0]-X_MIN) < epsilon) || ( (fabs(X{r}[0]-X_MAX) < epsilon) )) {
			Mt{r} = I;
			bt{r}[0] = 0.0;
			bt{r}[1] = 0.0;
		}
	}
}

ComputeU: ∀r∈nodes(), ur{r} = matVectProduct(inverse(Mt{r}), bt{r});
ComputeV: ∀j∈cells(), V{j} = 0.5 * ∑{r∈nodesOfCell(j)}(dot(C{j,r},X{r}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn: ∀r∈nodes(), X^{n+1}{r} = X{r}+δt*ur{r};
IniUn: ∀j∈cells(), { uj{j}[0] = 0.0; uj{j}[1] = 0.0; }
ComputeUn: ∀j∈cells(), uj^{n+1}{j} = uj{j} - (δt/m{j}) * ∑{r∈nodesOfCell(j)}(F{j,r});
IniEn: ∀j∈cells(), E{j} = p_ic{j} / ((γ-1.0) * ρ_ic{j});
ComputeEn: ∀j∈cells(), E^{n+1}{j} = E{j} - (δt / m{j}) * ∑{r∈nodesOfCell(j)}(dot(F{j,r}, ur{r}));
ComputeDt: δt^{n+1} = option_δt_cfl * Min{j∈cells()}(δtj{j});
ComputeTn: t^{n+1} = t+δt^{n+1};
